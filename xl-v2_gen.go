package main

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *XLMetaV2) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Version":
			z.Version, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "Format":
			z.Format, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Format")
				return
			}
		case "XL":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "XL")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "XL")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Journal":
					var zb0003 uint32
					zb0003, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "XL", "Journal")
						return
					}
					if cap(z.XL.Journal) >= int(zb0003) {
						z.XL.Journal = (z.XL.Journal)[:zb0003]
					} else {
						z.XL.Journal = make([]XLMetaV2JournalEntry, zb0003)
					}
					for za0001 := range z.XL.Journal {
						err = z.XL.Journal[za0001].DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "XL", "Journal", za0001)
							return
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "XL")
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *XLMetaV2) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "Version"
	err = en.Append(0x83, 0xa7, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Version)
	if err != nil {
		err = msgp.WrapError(err, "Version")
		return
	}
	// write "Format"
	err = en.Append(0xa6, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Format)
	if err != nil {
		err = msgp.WrapError(err, "Format")
		return
	}
	// write "XL"
	err = en.Append(0xa2, 0x58, 0x4c)
	if err != nil {
		return
	}
	// map header, size 1
	// write "Journal"
	err = en.Append(0x81, 0xa7, 0x4a, 0x6f, 0x75, 0x72, 0x6e, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.XL.Journal)))
	if err != nil {
		err = msgp.WrapError(err, "XL", "Journal")
		return
	}
	for za0001 := range z.XL.Journal {
		err = z.XL.Journal[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "XL", "Journal", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *XLMetaV2) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Version"
	o = append(o, 0x83, 0xa7, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Version)
	// string "Format"
	o = append(o, 0xa6, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74)
	o = msgp.AppendString(o, z.Format)
	// string "XL"
	o = append(o, 0xa2, 0x58, 0x4c)
	// map header, size 1
	// string "Journal"
	o = append(o, 0x81, 0xa7, 0x4a, 0x6f, 0x75, 0x72, 0x6e, 0x61, 0x6c)
	o = msgp.AppendArrayHeader(o, uint32(len(z.XL.Journal)))
	for za0001 := range z.XL.Journal {
		o, err = z.XL.Journal[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "XL", "Journal", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *XLMetaV2) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Version":
			z.Version, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "Format":
			z.Format, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Format")
				return
			}
		case "XL":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "XL")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "XL")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Journal":
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "XL", "Journal")
						return
					}
					if cap(z.XL.Journal) >= int(zb0003) {
						z.XL.Journal = (z.XL.Journal)[:zb0003]
					} else {
						z.XL.Journal = make([]XLMetaV2JournalEntry, zb0003)
					}
					for za0001 := range z.XL.Journal {
						bts, err = z.XL.Journal[za0001].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "XL", "Journal", za0001)
							return
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "XL")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *XLMetaV2) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Version) + 7 + msgp.StringPrefixSize + len(z.Format) + 3 + 1 + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.XL.Journal {
		s += z.XL.Journal[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *XLMetaV2DeleteMarker) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "VersionID":
			z.VersionID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "VersionID")
				return
			}
		case "ModTime":
			z.ModTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "ModTime")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z XLMetaV2DeleteMarker) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "VersionID"
	err = en.Append(0x82, 0xa9, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.VersionID)
	if err != nil {
		err = msgp.WrapError(err, "VersionID")
		return
	}
	// write "ModTime"
	err = en.Append(0xa7, 0x4d, 0x6f, 0x64, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.ModTime)
	if err != nil {
		err = msgp.WrapError(err, "ModTime")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z XLMetaV2DeleteMarker) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "VersionID"
	o = append(o, 0x82, 0xa9, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.VersionID)
	// string "ModTime"
	o = append(o, 0xa7, 0x4d, 0x6f, 0x64, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.ModTime)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *XLMetaV2DeleteMarker) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "VersionID":
			z.VersionID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VersionID")
				return
			}
		case "ModTime":
			z.ModTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ModTime")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z XLMetaV2DeleteMarker) Msgsize() (s int) {
	s = 1 + 10 + msgp.StringPrefixSize + len(z.VersionID) + 8 + msgp.TimeSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *XLMetaV2JournalEntry) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "DeleteMarker":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarker")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "DeleteMarker")
					return
				}
				switch msgp.UnsafeString(field) {
				case "VersionID":
					z.DeleteMarker.VersionID, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarker", "VersionID")
						return
					}
				case "ModTime":
					z.DeleteMarker.ModTime, err = dc.ReadTime()
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarker", "ModTime")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarker")
						return
					}
				}
			}
		case "Object":
			err = z.Object.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "Link":
			err = z.Link.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Link")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *XLMetaV2JournalEntry) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "Type"
	err = en.Append(0x84, 0xa4, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "DeleteMarker"
	err = en.Append(0xac, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72)
	if err != nil {
		return
	}
	// map header, size 2
	// write "VersionID"
	err = en.Append(0x82, 0xa9, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.DeleteMarker.VersionID)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarker", "VersionID")
		return
	}
	// write "ModTime"
	err = en.Append(0xa7, 0x4d, 0x6f, 0x64, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.DeleteMarker.ModTime)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarker", "ModTime")
		return
	}
	// write "Object"
	err = en.Append(0xa6, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = z.Object.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "Link"
	err = en.Append(0xa4, 0x4c, 0x69, 0x6e, 0x6b)
	if err != nil {
		return
	}
	err = z.Link.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Link")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *XLMetaV2JournalEntry) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Type"
	o = append(o, 0x84, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "DeleteMarker"
	o = append(o, 0xac, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72)
	// map header, size 2
	// string "VersionID"
	o = append(o, 0x82, 0xa9, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.DeleteMarker.VersionID)
	// string "ModTime"
	o = append(o, 0xa7, 0x4d, 0x6f, 0x64, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.DeleteMarker.ModTime)
	// string "Object"
	o = append(o, 0xa6, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o, err = z.Object.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// string "Link"
	o = append(o, 0xa4, 0x4c, 0x69, 0x6e, 0x6b)
	o, err = z.Link.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Link")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *XLMetaV2JournalEntry) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "DeleteMarker":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarker")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "DeleteMarker")
					return
				}
				switch msgp.UnsafeString(field) {
				case "VersionID":
					z.DeleteMarker.VersionID, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarker", "VersionID")
						return
					}
				case "ModTime":
					z.DeleteMarker.ModTime, bts, err = msgp.ReadTimeBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarker", "ModTime")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarker")
						return
					}
				}
			}
		case "Object":
			bts, err = z.Object.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "Link":
			bts, err = z.Link.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Link")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *XLMetaV2JournalEntry) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 13 + 1 + 10 + msgp.StringPrefixSize + len(z.DeleteMarker.VersionID) + 8 + msgp.TimeSize + 7 + z.Object.Msgsize() + 5 + z.Link.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *XLMetaV2Link) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "VersionID":
			z.VersionID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "VersionID")
				return
			}
		case "Data":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Data")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Dir":
					z.Data.Dir, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Data", "Dir")
						return
					}
				case "Erasure":
					var zb0003 uint32
					zb0003, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Data", "Erasure")
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Data", "Erasure")
							return
						}
						switch msgp.UnsafeString(field) {
						case "Algorithm":
							z.Data.Erasure.Algorithm, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Algorithm")
								return
							}
						case "Data":
							z.Data.Erasure.Data, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Data")
								return
							}
						case "Parity":
							z.Data.Erasure.Parity, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Parity")
								return
							}
						case "BlockSize":
							z.Data.Erasure.BlockSize, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "BlockSize")
								return
							}
						case "Index":
							z.Data.Erasure.Index, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Index")
								return
							}
						case "Distribution":
							var zb0004 uint32
							zb0004, err = dc.ReadArrayHeader()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Distribution")
								return
							}
							if cap(z.Data.Erasure.Distribution) >= int(zb0004) {
								z.Data.Erasure.Distribution = (z.Data.Erasure.Distribution)[:zb0004]
							} else {
								z.Data.Erasure.Distribution = make([]int, zb0004)
							}
							for za0001 := range z.Data.Erasure.Distribution {
								z.Data.Erasure.Distribution[za0001], err = dc.ReadInt()
								if err != nil {
									err = msgp.WrapError(err, "Data", "Erasure", "Distribution", za0001)
									return
								}
							}
						case "Checksum":
							var zb0005 uint32
							zb0005, err = dc.ReadMapHeader()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
								return
							}
							for zb0005 > 0 {
								zb0005--
								field, err = dc.ReadMapKeyPtr()
								if err != nil {
									err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
									return
								}
								switch msgp.UnsafeString(field) {
								case "Algorithm":
									z.Data.Erasure.Checksum.Algorithm, err = dc.ReadString()
									if err != nil {
										err = msgp.WrapError(err, "Data", "Erasure", "Checksum", "Algorithm")
										return
									}
								default:
									err = dc.Skip()
									if err != nil {
										err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
										return
									}
								}
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure")
								return
							}
						}
					}
				case "Parts":
					var zb0006 uint32
					zb0006, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Data", "Parts")
						return
					}
					if cap(z.Data.Parts) >= int(zb0006) {
						z.Data.Parts = (z.Data.Parts)[:zb0006]
					} else {
						z.Data.Parts = make([]struct {
							Number int `json:"number"`
							Size   int `json:"size"`
						}, zb0006)
					}
					for za0002 := range z.Data.Parts {
						var zb0007 uint32
						zb0007, err = dc.ReadMapHeader()
						if err != nil {
							err = msgp.WrapError(err, "Data", "Parts", za0002)
							return
						}
						for zb0007 > 0 {
							zb0007--
							field, err = dc.ReadMapKeyPtr()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Parts", za0002)
								return
							}
							switch msgp.UnsafeString(field) {
							case "Number":
								z.Data.Parts[za0002].Number, err = dc.ReadInt()
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002, "Number")
									return
								}
							case "Size":
								z.Data.Parts[za0002].Size, err = dc.ReadInt()
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002, "Size")
									return
								}
							default:
								err = dc.Skip()
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002)
									return
								}
							}
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Data")
						return
					}
				}
			}
		case "Stat":
			var zb0008 uint32
			zb0008, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Stat")
				return
			}
			for zb0008 > 0 {
				zb0008--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Stat")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Size":
					z.Stat.Size, err = dc.ReadInt()
					if err != nil {
						err = msgp.WrapError(err, "Stat", "Size")
						return
					}
				case "ModTime":
					z.Stat.ModTime, err = dc.ReadTime()
					if err != nil {
						err = msgp.WrapError(err, "Stat", "ModTime")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Stat")
						return
					}
				}
			}
		case "Meta":
			var zb0009 uint32
			zb0009, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Meta")
				return
			}
			for zb0009 > 0 {
				zb0009--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Meta")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Sys":
					var zb0010 uint32
					zb0010, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Meta", "Sys")
						return
					}
					if z.Meta.Sys == nil {
						z.Meta.Sys = make(map[string]string, zb0010)
					} else if len(z.Meta.Sys) > 0 {
						for key := range z.Meta.Sys {
							delete(z.Meta.Sys, key)
						}
					}
					for zb0010 > 0 {
						zb0010--
						var za0003 string
						var za0004 string
						za0003, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Meta", "Sys")
							return
						}
						za0004, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Meta", "Sys", za0003)
							return
						}
						z.Meta.Sys[za0003] = za0004
					}
				case "User":
					var zb0011 uint32
					zb0011, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Meta", "User")
						return
					}
					if z.Meta.User == nil {
						z.Meta.User = make(map[string]string, zb0011)
					} else if len(z.Meta.User) > 0 {
						for key := range z.Meta.User {
							delete(z.Meta.User, key)
						}
					}
					for zb0011 > 0 {
						zb0011--
						var za0005 string
						var za0006 string
						za0005, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Meta", "User")
							return
						}
						za0006, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Meta", "User", za0005)
							return
						}
						z.Meta.User[za0005] = za0006
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Meta")
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *XLMetaV2Link) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "VersionID"
	err = en.Append(0x84, 0xa9, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.VersionID)
	if err != nil {
		err = msgp.WrapError(err, "VersionID")
		return
	}
	// write "Data"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	// map header, size 3
	// write "Dir"
	err = en.Append(0x83, 0xa3, 0x44, 0x69, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Data.Dir)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Dir")
		return
	}
	// write "Erasure"
	err = en.Append(0xa7, 0x45, 0x72, 0x61, 0x73, 0x75, 0x72, 0x65)
	if err != nil {
		return
	}
	// map header, size 7
	// write "Algorithm"
	err = en.Append(0x87, 0xa9, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Data.Erasure.Algorithm)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Algorithm")
		return
	}
	// write "Data"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Data.Erasure.Data)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Data")
		return
	}
	// write "Parity"
	err = en.Append(0xa6, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Data.Erasure.Parity)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Parity")
		return
	}
	// write "BlockSize"
	err = en.Append(0xa9, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Data.Erasure.BlockSize)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "BlockSize")
		return
	}
	// write "Index"
	err = en.Append(0xa5, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Data.Erasure.Index)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Index")
		return
	}
	// write "Distribution"
	err = en.Append(0xac, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Data.Erasure.Distribution)))
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Distribution")
		return
	}
	for za0001 := range z.Data.Erasure.Distribution {
		err = en.WriteInt(z.Data.Erasure.Distribution[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Data", "Erasure", "Distribution", za0001)
			return
		}
	}
	// write "Checksum"
	err = en.Append(0xa8, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d)
	if err != nil {
		return
	}
	// map header, size 1
	// write "Algorithm"
	err = en.Append(0x81, 0xa9, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Data.Erasure.Checksum.Algorithm)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Checksum", "Algorithm")
		return
	}
	// write "Parts"
	err = en.Append(0xa5, 0x50, 0x61, 0x72, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Data.Parts)))
	if err != nil {
		err = msgp.WrapError(err, "Data", "Parts")
		return
	}
	for za0002 := range z.Data.Parts {
		// map header, size 2
		// write "Number"
		err = en.Append(0x82, 0xa6, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Data.Parts[za0002].Number)
		if err != nil {
			err = msgp.WrapError(err, "Data", "Parts", za0002, "Number")
			return
		}
		// write "Size"
		err = en.Append(0xa4, 0x53, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Data.Parts[za0002].Size)
		if err != nil {
			err = msgp.WrapError(err, "Data", "Parts", za0002, "Size")
			return
		}
	}
	// write "Stat"
	err = en.Append(0xa4, 0x53, 0x74, 0x61, 0x74)
	if err != nil {
		return
	}
	// map header, size 2
	// write "Size"
	err = en.Append(0x82, 0xa4, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat.Size)
	if err != nil {
		err = msgp.WrapError(err, "Stat", "Size")
		return
	}
	// write "ModTime"
	err = en.Append(0xa7, 0x4d, 0x6f, 0x64, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.Stat.ModTime)
	if err != nil {
		err = msgp.WrapError(err, "Stat", "ModTime")
		return
	}
	// write "Meta"
	err = en.Append(0xa4, 0x4d, 0x65, 0x74, 0x61)
	if err != nil {
		return
	}
	// map header, size 2
	// write "Sys"
	err = en.Append(0x82, 0xa3, 0x53, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Meta.Sys)))
	if err != nil {
		err = msgp.WrapError(err, "Meta", "Sys")
		return
	}
	for za0003, za0004 := range z.Meta.Sys {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "Meta", "Sys")
			return
		}
		err = en.WriteString(za0004)
		if err != nil {
			err = msgp.WrapError(err, "Meta", "Sys", za0003)
			return
		}
	}
	// write "User"
	err = en.Append(0xa4, 0x55, 0x73, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Meta.User)))
	if err != nil {
		err = msgp.WrapError(err, "Meta", "User")
		return
	}
	for za0005, za0006 := range z.Meta.User {
		err = en.WriteString(za0005)
		if err != nil {
			err = msgp.WrapError(err, "Meta", "User")
			return
		}
		err = en.WriteString(za0006)
		if err != nil {
			err = msgp.WrapError(err, "Meta", "User", za0005)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *XLMetaV2Link) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "VersionID"
	o = append(o, 0x84, 0xa9, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.VersionID)
	// string "Data"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x61)
	// map header, size 3
	// string "Dir"
	o = append(o, 0x83, 0xa3, 0x44, 0x69, 0x72)
	o = msgp.AppendString(o, z.Data.Dir)
	// string "Erasure"
	o = append(o, 0xa7, 0x45, 0x72, 0x61, 0x73, 0x75, 0x72, 0x65)
	// map header, size 7
	// string "Algorithm"
	o = append(o, 0x87, 0xa9, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d)
	o = msgp.AppendString(o, z.Data.Erasure.Algorithm)
	// string "Data"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendInt(o, z.Data.Erasure.Data)
	// string "Parity"
	o = append(o, 0xa6, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendInt(o, z.Data.Erasure.Parity)
	// string "BlockSize"
	o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Data.Erasure.BlockSize)
	// string "Index"
	o = append(o, 0xa5, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.Data.Erasure.Index)
	// string "Distribution"
	o = append(o, 0xac, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Data.Erasure.Distribution)))
	for za0001 := range z.Data.Erasure.Distribution {
		o = msgp.AppendInt(o, z.Data.Erasure.Distribution[za0001])
	}
	// string "Checksum"
	o = append(o, 0xa8, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d)
	// map header, size 1
	// string "Algorithm"
	o = append(o, 0x81, 0xa9, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d)
	o = msgp.AppendString(o, z.Data.Erasure.Checksum.Algorithm)
	// string "Parts"
	o = append(o, 0xa5, 0x50, 0x61, 0x72, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Data.Parts)))
	for za0002 := range z.Data.Parts {
		// map header, size 2
		// string "Number"
		o = append(o, 0x82, 0xa6, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
		o = msgp.AppendInt(o, z.Data.Parts[za0002].Number)
		// string "Size"
		o = append(o, 0xa4, 0x53, 0x69, 0x7a, 0x65)
		o = msgp.AppendInt(o, z.Data.Parts[za0002].Size)
	}
	// string "Stat"
	o = append(o, 0xa4, 0x53, 0x74, 0x61, 0x74)
	// map header, size 2
	// string "Size"
	o = append(o, 0x82, 0xa4, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Stat.Size)
	// string "ModTime"
	o = append(o, 0xa7, 0x4d, 0x6f, 0x64, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.Stat.ModTime)
	// string "Meta"
	o = append(o, 0xa4, 0x4d, 0x65, 0x74, 0x61)
	// map header, size 2
	// string "Sys"
	o = append(o, 0x82, 0xa3, 0x53, 0x79, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Meta.Sys)))
	for za0003, za0004 := range z.Meta.Sys {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendString(o, za0004)
	}
	// string "User"
	o = append(o, 0xa4, 0x55, 0x73, 0x65, 0x72)
	o = msgp.AppendMapHeader(o, uint32(len(z.Meta.User)))
	for za0005, za0006 := range z.Meta.User {
		o = msgp.AppendString(o, za0005)
		o = msgp.AppendString(o, za0006)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *XLMetaV2Link) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "VersionID":
			z.VersionID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VersionID")
				return
			}
		case "Data":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Data")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Dir":
					z.Data.Dir, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Dir")
						return
					}
				case "Erasure":
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Erasure")
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Data", "Erasure")
							return
						}
						switch msgp.UnsafeString(field) {
						case "Algorithm":
							z.Data.Erasure.Algorithm, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Algorithm")
								return
							}
						case "Data":
							z.Data.Erasure.Data, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Data")
								return
							}
						case "Parity":
							z.Data.Erasure.Parity, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Parity")
								return
							}
						case "BlockSize":
							z.Data.Erasure.BlockSize, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "BlockSize")
								return
							}
						case "Index":
							z.Data.Erasure.Index, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Index")
								return
							}
						case "Distribution":
							var zb0004 uint32
							zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Distribution")
								return
							}
							if cap(z.Data.Erasure.Distribution) >= int(zb0004) {
								z.Data.Erasure.Distribution = (z.Data.Erasure.Distribution)[:zb0004]
							} else {
								z.Data.Erasure.Distribution = make([]int, zb0004)
							}
							for za0001 := range z.Data.Erasure.Distribution {
								z.Data.Erasure.Distribution[za0001], bts, err = msgp.ReadIntBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Data", "Erasure", "Distribution", za0001)
									return
								}
							}
						case "Checksum":
							var zb0005 uint32
							zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
								return
							}
							for zb0005 > 0 {
								zb0005--
								field, bts, err = msgp.ReadMapKeyZC(bts)
								if err != nil {
									err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
									return
								}
								switch msgp.UnsafeString(field) {
								case "Algorithm":
									z.Data.Erasure.Checksum.Algorithm, bts, err = msgp.ReadStringBytes(bts)
									if err != nil {
										err = msgp.WrapError(err, "Data", "Erasure", "Checksum", "Algorithm")
										return
									}
								default:
									bts, err = msgp.Skip(bts)
									if err != nil {
										err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
										return
									}
								}
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure")
								return
							}
						}
					}
				case "Parts":
					var zb0006 uint32
					zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Parts")
						return
					}
					if cap(z.Data.Parts) >= int(zb0006) {
						z.Data.Parts = (z.Data.Parts)[:zb0006]
					} else {
						z.Data.Parts = make([]struct {
							Number int `json:"number"`
							Size   int `json:"size"`
						}, zb0006)
					}
					for za0002 := range z.Data.Parts {
						var zb0007 uint32
						zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Data", "Parts", za0002)
							return
						}
						for zb0007 > 0 {
							zb0007--
							field, bts, err = msgp.ReadMapKeyZC(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Parts", za0002)
								return
							}
							switch msgp.UnsafeString(field) {
							case "Number":
								z.Data.Parts[za0002].Number, bts, err = msgp.ReadIntBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002, "Number")
									return
								}
							case "Size":
								z.Data.Parts[za0002].Size, bts, err = msgp.ReadIntBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002, "Size")
									return
								}
							default:
								bts, err = msgp.Skip(bts)
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002)
									return
								}
							}
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data")
						return
					}
				}
			}
		case "Stat":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat")
				return
			}
			for zb0008 > 0 {
				zb0008--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stat")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Size":
					z.Stat.Size, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Stat", "Size")
						return
					}
				case "ModTime":
					z.Stat.ModTime, bts, err = msgp.ReadTimeBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Stat", "ModTime")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Stat")
						return
					}
				}
			}
		case "Meta":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Meta")
				return
			}
			for zb0009 > 0 {
				zb0009--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Meta")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Sys":
					var zb0010 uint32
					zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Meta", "Sys")
						return
					}
					if z.Meta.Sys == nil {
						z.Meta.Sys = make(map[string]string, zb0010)
					} else if len(z.Meta.Sys) > 0 {
						for key := range z.Meta.Sys {
							delete(z.Meta.Sys, key)
						}
					}
					for zb0010 > 0 {
						var za0003 string
						var za0004 string
						zb0010--
						za0003, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Meta", "Sys")
							return
						}
						za0004, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Meta", "Sys", za0003)
							return
						}
						z.Meta.Sys[za0003] = za0004
					}
				case "User":
					var zb0011 uint32
					zb0011, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Meta", "User")
						return
					}
					if z.Meta.User == nil {
						z.Meta.User = make(map[string]string, zb0011)
					} else if len(z.Meta.User) > 0 {
						for key := range z.Meta.User {
							delete(z.Meta.User, key)
						}
					}
					for zb0011 > 0 {
						var za0005 string
						var za0006 string
						zb0011--
						za0005, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Meta", "User")
							return
						}
						za0006, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Meta", "User", za0005)
							return
						}
						z.Meta.User[za0005] = za0006
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Meta")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *XLMetaV2Link) Msgsize() (s int) {
	s = 1 + 10 + msgp.StringPrefixSize + len(z.VersionID) + 5 + 1 + 4 + msgp.StringPrefixSize + len(z.Data.Dir) + 8 + 1 + 10 + msgp.StringPrefixSize + len(z.Data.Erasure.Algorithm) + 5 + msgp.IntSize + 7 + msgp.IntSize + 10 + msgp.IntSize + 6 + msgp.IntSize + 13 + msgp.ArrayHeaderSize + (len(z.Data.Erasure.Distribution) * (msgp.IntSize)) + 9 + 1 + 10 + msgp.StringPrefixSize + len(z.Data.Erasure.Checksum.Algorithm) + 6 + msgp.ArrayHeaderSize + (len(z.Data.Parts) * (13 + msgp.IntSize + msgp.IntSize)) + 5 + 1 + 5 + msgp.IntSize + 8 + msgp.TimeSize + 5 + 1 + 4 + msgp.MapHeaderSize
	if z.Meta.Sys != nil {
		for za0003, za0004 := range z.Meta.Sys {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.StringPrefixSize + len(za0004)
		}
	}
	s += 5 + msgp.MapHeaderSize
	if z.Meta.User != nil {
		for za0005, za0006 := range z.Meta.User {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + msgp.StringPrefixSize + len(za0006)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *XLMetaV2Object) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "VersionID":
			z.VersionID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "VersionID")
				return
			}
		case "Data":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Data")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Dir":
					z.Data.Dir, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Data", "Dir")
						return
					}
				case "Erasure":
					var zb0003 uint32
					zb0003, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Data", "Erasure")
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Data", "Erasure")
							return
						}
						switch msgp.UnsafeString(field) {
						case "Algorithm":
							z.Data.Erasure.Algorithm, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Algorithm")
								return
							}
						case "Data":
							z.Data.Erasure.Data, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Data")
								return
							}
						case "Parity":
							z.Data.Erasure.Parity, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Parity")
								return
							}
						case "BlockSize":
							z.Data.Erasure.BlockSize, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "BlockSize")
								return
							}
						case "Index":
							z.Data.Erasure.Index, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Index")
								return
							}
						case "Distribution":
							var zb0004 uint32
							zb0004, err = dc.ReadArrayHeader()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Distribution")
								return
							}
							if cap(z.Data.Erasure.Distribution) >= int(zb0004) {
								z.Data.Erasure.Distribution = (z.Data.Erasure.Distribution)[:zb0004]
							} else {
								z.Data.Erasure.Distribution = make([]int, zb0004)
							}
							for za0001 := range z.Data.Erasure.Distribution {
								z.Data.Erasure.Distribution[za0001], err = dc.ReadInt()
								if err != nil {
									err = msgp.WrapError(err, "Data", "Erasure", "Distribution", za0001)
									return
								}
							}
						case "Checksum":
							var zb0005 uint32
							zb0005, err = dc.ReadMapHeader()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
								return
							}
							for zb0005 > 0 {
								zb0005--
								field, err = dc.ReadMapKeyPtr()
								if err != nil {
									err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
									return
								}
								switch msgp.UnsafeString(field) {
								case "Algorithm":
									z.Data.Erasure.Checksum.Algorithm, err = dc.ReadString()
									if err != nil {
										err = msgp.WrapError(err, "Data", "Erasure", "Checksum", "Algorithm")
										return
									}
								default:
									err = dc.Skip()
									if err != nil {
										err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
										return
									}
								}
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure")
								return
							}
						}
					}
				case "Parts":
					var zb0006 uint32
					zb0006, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Data", "Parts")
						return
					}
					if cap(z.Data.Parts) >= int(zb0006) {
						z.Data.Parts = (z.Data.Parts)[:zb0006]
					} else {
						z.Data.Parts = make([]struct {
							Number int `json:"number"`
							Size   int `json:"size"`
						}, zb0006)
					}
					for za0002 := range z.Data.Parts {
						var zb0007 uint32
						zb0007, err = dc.ReadMapHeader()
						if err != nil {
							err = msgp.WrapError(err, "Data", "Parts", za0002)
							return
						}
						for zb0007 > 0 {
							zb0007--
							field, err = dc.ReadMapKeyPtr()
							if err != nil {
								err = msgp.WrapError(err, "Data", "Parts", za0002)
								return
							}
							switch msgp.UnsafeString(field) {
							case "Number":
								z.Data.Parts[za0002].Number, err = dc.ReadInt()
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002, "Number")
									return
								}
							case "Size":
								z.Data.Parts[za0002].Size, err = dc.ReadInt()
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002, "Size")
									return
								}
							default:
								err = dc.Skip()
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002)
									return
								}
							}
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Data")
						return
					}
				}
			}
		case "Stat":
			var zb0008 uint32
			zb0008, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Stat")
				return
			}
			for zb0008 > 0 {
				zb0008--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Stat")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Size":
					z.Stat.Size, err = dc.ReadInt()
					if err != nil {
						err = msgp.WrapError(err, "Stat", "Size")
						return
					}
				case "ModTime":
					z.Stat.ModTime, err = dc.ReadTime()
					if err != nil {
						err = msgp.WrapError(err, "Stat", "ModTime")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Stat")
						return
					}
				}
			}
		case "Meta":
			var zb0009 uint32
			zb0009, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Meta")
				return
			}
			for zb0009 > 0 {
				zb0009--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Meta")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Sys":
					var zb0010 uint32
					zb0010, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Meta", "Sys")
						return
					}
					if z.Meta.Sys == nil {
						z.Meta.Sys = make(map[string]string, zb0010)
					} else if len(z.Meta.Sys) > 0 {
						for key := range z.Meta.Sys {
							delete(z.Meta.Sys, key)
						}
					}
					for zb0010 > 0 {
						zb0010--
						var za0003 string
						var za0004 string
						za0003, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Meta", "Sys")
							return
						}
						za0004, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Meta", "Sys", za0003)
							return
						}
						z.Meta.Sys[za0003] = za0004
					}
				case "User":
					var zb0011 uint32
					zb0011, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Meta", "User")
						return
					}
					if z.Meta.User == nil {
						z.Meta.User = make(map[string]string, zb0011)
					} else if len(z.Meta.User) > 0 {
						for key := range z.Meta.User {
							delete(z.Meta.User, key)
						}
					}
					for zb0011 > 0 {
						zb0011--
						var za0005 string
						var za0006 string
						za0005, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Meta", "User")
							return
						}
						za0006, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Meta", "User", za0005)
							return
						}
						z.Meta.User[za0005] = za0006
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Meta")
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *XLMetaV2Object) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "VersionID"
	err = en.Append(0x84, 0xa9, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.VersionID)
	if err != nil {
		err = msgp.WrapError(err, "VersionID")
		return
	}
	// write "Data"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	// map header, size 3
	// write "Dir"
	err = en.Append(0x83, 0xa3, 0x44, 0x69, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Data.Dir)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Dir")
		return
	}
	// write "Erasure"
	err = en.Append(0xa7, 0x45, 0x72, 0x61, 0x73, 0x75, 0x72, 0x65)
	if err != nil {
		return
	}
	// map header, size 7
	// write "Algorithm"
	err = en.Append(0x87, 0xa9, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Data.Erasure.Algorithm)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Algorithm")
		return
	}
	// write "Data"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Data.Erasure.Data)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Data")
		return
	}
	// write "Parity"
	err = en.Append(0xa6, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Data.Erasure.Parity)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Parity")
		return
	}
	// write "BlockSize"
	err = en.Append(0xa9, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Data.Erasure.BlockSize)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "BlockSize")
		return
	}
	// write "Index"
	err = en.Append(0xa5, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Data.Erasure.Index)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Index")
		return
	}
	// write "Distribution"
	err = en.Append(0xac, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Data.Erasure.Distribution)))
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Distribution")
		return
	}
	for za0001 := range z.Data.Erasure.Distribution {
		err = en.WriteInt(z.Data.Erasure.Distribution[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Data", "Erasure", "Distribution", za0001)
			return
		}
	}
	// write "Checksum"
	err = en.Append(0xa8, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d)
	if err != nil {
		return
	}
	// map header, size 1
	// write "Algorithm"
	err = en.Append(0x81, 0xa9, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Data.Erasure.Checksum.Algorithm)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Erasure", "Checksum", "Algorithm")
		return
	}
	// write "Parts"
	err = en.Append(0xa5, 0x50, 0x61, 0x72, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Data.Parts)))
	if err != nil {
		err = msgp.WrapError(err, "Data", "Parts")
		return
	}
	for za0002 := range z.Data.Parts {
		// map header, size 2
		// write "Number"
		err = en.Append(0x82, 0xa6, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Data.Parts[za0002].Number)
		if err != nil {
			err = msgp.WrapError(err, "Data", "Parts", za0002, "Number")
			return
		}
		// write "Size"
		err = en.Append(0xa4, 0x53, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Data.Parts[za0002].Size)
		if err != nil {
			err = msgp.WrapError(err, "Data", "Parts", za0002, "Size")
			return
		}
	}
	// write "Stat"
	err = en.Append(0xa4, 0x53, 0x74, 0x61, 0x74)
	if err != nil {
		return
	}
	// map header, size 2
	// write "Size"
	err = en.Append(0x82, 0xa4, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat.Size)
	if err != nil {
		err = msgp.WrapError(err, "Stat", "Size")
		return
	}
	// write "ModTime"
	err = en.Append(0xa7, 0x4d, 0x6f, 0x64, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.Stat.ModTime)
	if err != nil {
		err = msgp.WrapError(err, "Stat", "ModTime")
		return
	}
	// write "Meta"
	err = en.Append(0xa4, 0x4d, 0x65, 0x74, 0x61)
	if err != nil {
		return
	}
	// map header, size 2
	// write "Sys"
	err = en.Append(0x82, 0xa3, 0x53, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Meta.Sys)))
	if err != nil {
		err = msgp.WrapError(err, "Meta", "Sys")
		return
	}
	for za0003, za0004 := range z.Meta.Sys {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "Meta", "Sys")
			return
		}
		err = en.WriteString(za0004)
		if err != nil {
			err = msgp.WrapError(err, "Meta", "Sys", za0003)
			return
		}
	}
	// write "User"
	err = en.Append(0xa4, 0x55, 0x73, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Meta.User)))
	if err != nil {
		err = msgp.WrapError(err, "Meta", "User")
		return
	}
	for za0005, za0006 := range z.Meta.User {
		err = en.WriteString(za0005)
		if err != nil {
			err = msgp.WrapError(err, "Meta", "User")
			return
		}
		err = en.WriteString(za0006)
		if err != nil {
			err = msgp.WrapError(err, "Meta", "User", za0005)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *XLMetaV2Object) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "VersionID"
	o = append(o, 0x84, 0xa9, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.VersionID)
	// string "Data"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x61)
	// map header, size 3
	// string "Dir"
	o = append(o, 0x83, 0xa3, 0x44, 0x69, 0x72)
	o = msgp.AppendString(o, z.Data.Dir)
	// string "Erasure"
	o = append(o, 0xa7, 0x45, 0x72, 0x61, 0x73, 0x75, 0x72, 0x65)
	// map header, size 7
	// string "Algorithm"
	o = append(o, 0x87, 0xa9, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d)
	o = msgp.AppendString(o, z.Data.Erasure.Algorithm)
	// string "Data"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendInt(o, z.Data.Erasure.Data)
	// string "Parity"
	o = append(o, 0xa6, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendInt(o, z.Data.Erasure.Parity)
	// string "BlockSize"
	o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Data.Erasure.BlockSize)
	// string "Index"
	o = append(o, 0xa5, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.Data.Erasure.Index)
	// string "Distribution"
	o = append(o, 0xac, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Data.Erasure.Distribution)))
	for za0001 := range z.Data.Erasure.Distribution {
		o = msgp.AppendInt(o, z.Data.Erasure.Distribution[za0001])
	}
	// string "Checksum"
	o = append(o, 0xa8, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d)
	// map header, size 1
	// string "Algorithm"
	o = append(o, 0x81, 0xa9, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d)
	o = msgp.AppendString(o, z.Data.Erasure.Checksum.Algorithm)
	// string "Parts"
	o = append(o, 0xa5, 0x50, 0x61, 0x72, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Data.Parts)))
	for za0002 := range z.Data.Parts {
		// map header, size 2
		// string "Number"
		o = append(o, 0x82, 0xa6, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
		o = msgp.AppendInt(o, z.Data.Parts[za0002].Number)
		// string "Size"
		o = append(o, 0xa4, 0x53, 0x69, 0x7a, 0x65)
		o = msgp.AppendInt(o, z.Data.Parts[za0002].Size)
	}
	// string "Stat"
	o = append(o, 0xa4, 0x53, 0x74, 0x61, 0x74)
	// map header, size 2
	// string "Size"
	o = append(o, 0x82, 0xa4, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Stat.Size)
	// string "ModTime"
	o = append(o, 0xa7, 0x4d, 0x6f, 0x64, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.Stat.ModTime)
	// string "Meta"
	o = append(o, 0xa4, 0x4d, 0x65, 0x74, 0x61)
	// map header, size 2
	// string "Sys"
	o = append(o, 0x82, 0xa3, 0x53, 0x79, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Meta.Sys)))
	for za0003, za0004 := range z.Meta.Sys {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendString(o, za0004)
	}
	// string "User"
	o = append(o, 0xa4, 0x55, 0x73, 0x65, 0x72)
	o = msgp.AppendMapHeader(o, uint32(len(z.Meta.User)))
	for za0005, za0006 := range z.Meta.User {
		o = msgp.AppendString(o, za0005)
		o = msgp.AppendString(o, za0006)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *XLMetaV2Object) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "VersionID":
			z.VersionID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VersionID")
				return
			}
		case "Data":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Data")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Dir":
					z.Data.Dir, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Dir")
						return
					}
				case "Erasure":
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Erasure")
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Data", "Erasure")
							return
						}
						switch msgp.UnsafeString(field) {
						case "Algorithm":
							z.Data.Erasure.Algorithm, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Algorithm")
								return
							}
						case "Data":
							z.Data.Erasure.Data, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Data")
								return
							}
						case "Parity":
							z.Data.Erasure.Parity, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Parity")
								return
							}
						case "BlockSize":
							z.Data.Erasure.BlockSize, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "BlockSize")
								return
							}
						case "Index":
							z.Data.Erasure.Index, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Index")
								return
							}
						case "Distribution":
							var zb0004 uint32
							zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Distribution")
								return
							}
							if cap(z.Data.Erasure.Distribution) >= int(zb0004) {
								z.Data.Erasure.Distribution = (z.Data.Erasure.Distribution)[:zb0004]
							} else {
								z.Data.Erasure.Distribution = make([]int, zb0004)
							}
							for za0001 := range z.Data.Erasure.Distribution {
								z.Data.Erasure.Distribution[za0001], bts, err = msgp.ReadIntBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Data", "Erasure", "Distribution", za0001)
									return
								}
							}
						case "Checksum":
							var zb0005 uint32
							zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
								return
							}
							for zb0005 > 0 {
								zb0005--
								field, bts, err = msgp.ReadMapKeyZC(bts)
								if err != nil {
									err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
									return
								}
								switch msgp.UnsafeString(field) {
								case "Algorithm":
									z.Data.Erasure.Checksum.Algorithm, bts, err = msgp.ReadStringBytes(bts)
									if err != nil {
										err = msgp.WrapError(err, "Data", "Erasure", "Checksum", "Algorithm")
										return
									}
								default:
									bts, err = msgp.Skip(bts)
									if err != nil {
										err = msgp.WrapError(err, "Data", "Erasure", "Checksum")
										return
									}
								}
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Erasure")
								return
							}
						}
					}
				case "Parts":
					var zb0006 uint32
					zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Parts")
						return
					}
					if cap(z.Data.Parts) >= int(zb0006) {
						z.Data.Parts = (z.Data.Parts)[:zb0006]
					} else {
						z.Data.Parts = make([]struct {
							Number int `json:"number"`
							Size   int `json:"size"`
						}, zb0006)
					}
					for za0002 := range z.Data.Parts {
						var zb0007 uint32
						zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Data", "Parts", za0002)
							return
						}
						for zb0007 > 0 {
							zb0007--
							field, bts, err = msgp.ReadMapKeyZC(bts)
							if err != nil {
								err = msgp.WrapError(err, "Data", "Parts", za0002)
								return
							}
							switch msgp.UnsafeString(field) {
							case "Number":
								z.Data.Parts[za0002].Number, bts, err = msgp.ReadIntBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002, "Number")
									return
								}
							case "Size":
								z.Data.Parts[za0002].Size, bts, err = msgp.ReadIntBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002, "Size")
									return
								}
							default:
								bts, err = msgp.Skip(bts)
								if err != nil {
									err = msgp.WrapError(err, "Data", "Parts", za0002)
									return
								}
							}
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data")
						return
					}
				}
			}
		case "Stat":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat")
				return
			}
			for zb0008 > 0 {
				zb0008--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stat")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Size":
					z.Stat.Size, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Stat", "Size")
						return
					}
				case "ModTime":
					z.Stat.ModTime, bts, err = msgp.ReadTimeBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Stat", "ModTime")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Stat")
						return
					}
				}
			}
		case "Meta":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Meta")
				return
			}
			for zb0009 > 0 {
				zb0009--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Meta")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Sys":
					var zb0010 uint32
					zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Meta", "Sys")
						return
					}
					if z.Meta.Sys == nil {
						z.Meta.Sys = make(map[string]string, zb0010)
					} else if len(z.Meta.Sys) > 0 {
						for key := range z.Meta.Sys {
							delete(z.Meta.Sys, key)
						}
					}
					for zb0010 > 0 {
						var za0003 string
						var za0004 string
						zb0010--
						za0003, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Meta", "Sys")
							return
						}
						za0004, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Meta", "Sys", za0003)
							return
						}
						z.Meta.Sys[za0003] = za0004
					}
				case "User":
					var zb0011 uint32
					zb0011, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Meta", "User")
						return
					}
					if z.Meta.User == nil {
						z.Meta.User = make(map[string]string, zb0011)
					} else if len(z.Meta.User) > 0 {
						for key := range z.Meta.User {
							delete(z.Meta.User, key)
						}
					}
					for zb0011 > 0 {
						var za0005 string
						var za0006 string
						zb0011--
						za0005, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Meta", "User")
							return
						}
						za0006, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Meta", "User", za0005)
							return
						}
						z.Meta.User[za0005] = za0006
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Meta")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *XLMetaV2Object) Msgsize() (s int) {
	s = 1 + 10 + msgp.StringPrefixSize + len(z.VersionID) + 5 + 1 + 4 + msgp.StringPrefixSize + len(z.Data.Dir) + 8 + 1 + 10 + msgp.StringPrefixSize + len(z.Data.Erasure.Algorithm) + 5 + msgp.IntSize + 7 + msgp.IntSize + 10 + msgp.IntSize + 6 + msgp.IntSize + 13 + msgp.ArrayHeaderSize + (len(z.Data.Erasure.Distribution) * (msgp.IntSize)) + 9 + 1 + 10 + msgp.StringPrefixSize + len(z.Data.Erasure.Checksum.Algorithm) + 6 + msgp.ArrayHeaderSize + (len(z.Data.Parts) * (13 + msgp.IntSize + msgp.IntSize)) + 5 + 1 + 5 + msgp.IntSize + 8 + msgp.TimeSize + 5 + 1 + 4 + msgp.MapHeaderSize
	if z.Meta.Sys != nil {
		for za0003, za0004 := range z.Meta.Sys {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.StringPrefixSize + len(za0004)
		}
	}
	s += 5 + msgp.MapHeaderSize
	if z.Meta.User != nil {
		for za0005, za0006 := range z.Meta.User {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + msgp.StringPrefixSize + len(za0006)
		}
	}
	return
}
